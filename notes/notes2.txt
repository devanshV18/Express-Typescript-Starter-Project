EXPRESS ERROR HANDLING

1. Error Handling refers to how Express catches and processes errors that occur both synchronously and asynchronously.

2. Errors that occur in synchronous code inside route handlers and middleware require no extra work. If synchronous code throws an error, then Express will catch and process it. For example:

app.get('/', (req, res) => {
  throw new Error('BROKEN') // Express will catch this on its own.
})

3. For errors returned from asynchronous functions invoked by route handlers and middleware, you must pass them to the next() function, where Express will catch and process them. For example:

app.get('/', (req, res, next) => {
  fs.readFile('/file-does-not-exist', (err, data) => {
    if (err) {
      next(err) // Pass errors to Express.
    } else {
      res.send(data)
    }
  })
})


Starting with Express 5, route handlers and middleware that return a Promise (Async middlewares/ async errors) will call next(error) automatically when they reject or throw an error. For example:

app.get('/user/:id', async (req, res, next) => {
  const user = await getUserById(req.params.id)
  res.send(user)
})

If getUserById throws an error or rejects, next will be called with either the thrown error or the rejected value. If no rejected value is provided, next will be called with a default Error object provided by the Express router.

4. You must catch errors that occur in asynchronous code invoked by route handlers or middleware and pass them to Express for processing. For example:

app.get('/', (req, res, next) => {
  setTimeout(() => {
    try {
      throw new Error('BROKEN')
    } catch (err) {
      next(err)
    }
  }, 100)
})

5. Express comes with a default error handler which is injected by express at the end of the terminal controller/middleware of the route by default. When we call the next() function with the async error we basically call the default error handler provided by express. 

//vvvi 
When you call next(error):

Express bypasses all non-error-handling middleware.

It jumps directly to the first error-handling middleware (those with the signature (err, req, res, next)). (exists if we define a custom error handling middleware)

If no custom error middleware is defined, Express invokes its default error handler. (at the end of the flow.)

6. Hence, if we pass an error to next() and you do not handle it in a custom error handler, it will be handled by the built-in error handler the error will be written to the client with the stack trace. 

7. n async functions, if an error is caught and passed to next(err), it follows the above logic—skipping to error-handling middleware.

//VVVII
CRUX FROM POINT 3-7 = Express has a default error handler that is automatically added at the end of the middleware stack. When next(err) is called (e.g., from a controller or async middleware), Express skips any remaining non-error-handling middleware and passes control directly to the next error-handling middleware in the chain. If no custom error handlers are defined, Express’s built-in default error handler will handle the error.

8. Alot of error handling may be done in the same way for multiple controllers where majority of the controllers might have the same or similar code handling their errors which is very tiring and unoptimised as it is repeated coding. So its better to implement a more generic or central error handler by somewhat leveraging or extending the default error handler provided to us by express. (Referring to approach at line 31 in pingHandler.ts)

9. to tell express about our custom error handling functions, we specify it as a middleware usage at the end of all the routes defined in server.ts

10. Starting with Express 5, route handlers and middleware that return a Promise will call next(value) automatically when they reject or throw an error. For example:

app.get('/user/:id', async (req, res, next) => {
  const user = await getUserById(req.params.id)
  res.send(user)
})
